// ************************************************************************
// Copyright (c) 2007   Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory.
// Written by the PSUADE team.
// All rights reserved.
//
// Please see the COPYRIGHT_and_LICENSE file for the copyright notice,
// disclaimer, contact information and the GNU Lesser General Public License.
//
// PSUADE is free software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License (as published by the Free Software
// Foundation) version 2.1 dated February 1999.
//
// PSUADE is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the terms and conditions of the GNU General
// Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// ************************************************************************
// Functions for the class UserRegression
// AUTHOR : CHARLES TONG
// DATE   : 2010
//**/ Evaluation with uncertainty added in Mar 2014
// ************************************************************************
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include "Psuade.h"
#include "UserRegression.h"
#include "sysdef.h"
#include "PsuadeUtil.h"
#include "PrintingTS.h"

#define PABS(x) (((x) > 0.0) ? (x) : -(x))

extern "C" {
  void dgesvd_(char *, char *, int *, int *, double *, int *, double *,
               double *, int *, double *, int *, double *, int *, int *);
}

// ************************************************************************
// Constructor 
// ------------------------------------------------------------------------
UserRegression::UserRegression(int nInputs,int nSamples):
                               FuncApprox(nInputs,nSamples)
{
  int  ii;
  char response[501], inLine[501], pString[501];
  FILE *fp;

  //**/ ==============================================================
  // display banner and additonal information
  //**/ ==============================================================
  printAsterisks(PL_INFO, 0);
  printf("*                User Regression Analysis\n");
  printf("* R-square gives a measure of the goodness of the model.\n");
  printf("* R-square should be close to 1 if it is a good model.\n");
  printf("* Turn on rs_expert mode to select input scaling.\n");
  printf("* Option to use a ps_user_regr_info file to feed information\n");
  printf("* Turn on rs_expert mode to skip regression analysis.\n");
  printf("* Create ps_user_regr_info file to set information.\n");
  printEquals(PL_INFO, 0);

  //**/ ===============================================================
  //**/ ask from user from information
  //**/ ==============================================================
  faID_ = PSUADE_RS_REGRU;
  strcpy(regFile_, "");
  fp = fopen("ps_user_regr_info", "r");
  if (fp == NULL)
  {
    printEquals(PL_INFO, 0);
    printf("UserRegression: this regression support the following ");
    printf("equation: \n");
    printf("          Y = sum_i^M alpha_i B_i(X)\n");
    printf("where B_i(X)'s are M user-provided basis functions and ");
    printf("alpha_i's are\n");
    printf("coefficients to be computed by fitting the sample data.\n");
    printf("This regression method needs 2 pieces of information ");
    printf("from users :\n");
    printf("  (1) number of basis functions in your regression (M).\n");
    printf("  (2) a user-generated executable file which evaluates\n");
    printf("      the basis functions given any set of sample points.\n");
    printf("      This file (say user.py) will be called via:\n\n");
    printf("          user.py paramfile outputfile \n\n");
    printf("       where param_file (generated by PSUADE) has the ");
    printf("format: \n");
    printf("       line 1: <N sample points> <number of inputs m>\n");
    printf("       line 2: 1 <input values for sample point 1>\n");
    printf("       line 3: 2 <input values for sample point 2>\n");
    printf("       .....\n");
    printf("       Outputfile (created by user.py) must have this ");
    printf("format:\n");
    printf("       line 1: 1 <M basis functions evaluated for sample 1> \n");
    printf("       line 2: 2 <M basis functions evaluated for sample 2> \n");
    printf("       .....\n");
    printEquals(PL_INFO, 0);
    sprintf(pString, "Enter number of basis function : ");
    numTerms_ = getInt(1,10000,pString);
    sprintf(pString, "Enter name of user-generated executable file : ");
    getString(pString, regFile_);
    ii = strlen(regFile_);
    regFile_[ii-1] = '\0';
    fp = fopen("ps_user_regr_info", "w");
    if (fp != NULL)
    {
      fprintf(fp, "%d\n", numTerms_);
      fprintf(fp, "%s\n", regFile_);
      fclose(fp);
      printf("UserRegression INFO: user info stored in ps_user_regr_info.\n");
    }
  }
  else
  {
    printf("UserRegression information file - ps_user_regr_info found.\n");
    fscanf(fp, "%d", &numTerms_);
    if (numTerms_ <= 0)
    {
      printf("UserRegression ERROR: numTerms should be > 0.\n");
      exit(1);
    }
    printf("UserRegression number of basis functions = %d\n",numTerms_);
    fscanf(fp, "%s", regFile_);
    printf("UserRegression user-provided executable  = %s\n",regFile_);
    fclose(fp);
    printf("INFO: If these settings are obsolete, delete ps_user_regr_info\n");
    printf("      and re-do this analysis.\n");
  }
  fp = fopen(regFile_, "r");
  if (fp == NULL)
  {
    printf("UserRegression ERROR: user-provided executable %s not found.\n",
           regFile_);
    exit(1);
  }
  fclose(fp);
 
  //**/ ==============================================================
  //**/ This module can be used for both specialized user-defined
  //**/ nonparametric regression or just for using user-provided
  //**/ response for UQ analysis. In the latter case, there will be no
  //**/ need to do detailed regression analysis (but then there will 
  //**/ be no response surface uncertainties available)
  //**/ ==============================================================
  noAnalysis_ = 0;
  if (numTerms_ == 1 && psConfig_.RSExpertModeIsOn())
  {
    printf("UserRegression: Since number of basis functions = 1, it ");
    printf("may not be\n");
    printf("    needed to compute the basis function coefficients. ");
    printf("Should we go\n");
    printf("    ahead with regression analysis (least-squares) to ");
    printf("compute the\n");
    printf("    basis function coefficients? (y or n) ");
    scanf("%s", response);
    fgets(inLine, 500, stdin);
    if (response[0] != 'y') noAnalysis_ = 1;
  }

  //**/ ==============================================================
  //**/ provide an option to scale the inputs to enhance stability.
  //**/ will only scale to [0,1] or [-1, 1] 
  //**/ ==============================================================
  vecXNShift_.setLength(nInputs_);
  vecXNScale_.setLength(nInputs_);
  vecXScales_.setLength(nInputs_);
  for (ii = 0; ii < nInputs_; ii++)
  {
    vecXNShift_[ii]  = 0.0; 
    vecXNScale_[ii] = 1.0; 
    vecXScales_[ii] = 0; 
  }
  if (noAnalysis_ == 0 && psConfig_.RSExpertModeIsOn())
  {
    printf("Perform input scaling ? (y or n) ");
    scanf("%s", response);
    fgets(inLine, 500, stdin);
    if (response[0] == 'y') 
    {
      printf("Select the type of scaling for each input.\n");
      printf("Available ones are: \n");
      printf("0. no scaling\n");
      printf("1. scale only (i.e. X' = X * scale)\n");
      printf("2. shift and scale (X' = (X - lower bound) * scale)\n");
      for (ii = 0; ii < nInputs_; ii++)
      {
        sprintf(pString,"Choose scaling type (0, 1 or 2) for input %d : ",
                ii+1);
        vecXScales_[ii] = getInt(0,2,pString);
      }
    }
  }

  //**/ ==============================================================
  //**/ check the user regression file
  //**/ ==============================================================
  fp = fopen(regFile_, "r");
  if (fp == NULL)
  {
    printf("UserRegression ERROR: user executable file not found.\n");
    printf("  This file is to be used for evaluating the basis ");
    printf("functions given any\n");
    printf("  set of sample points. This file (say user.py) will ");
    printf("be called via :\n\n");
    printf("        user.py paramfile outputfile \n\n");
    printf("  where param_file (generated by PSUADE) has the format: \n");
    printf("  line 1: <N sample points> <number of inputs m>\n");
    printf("  line 2: 1 <by input values for sample point 1>\n");
    printf("  line 3: 2 <by input values for sample point 2>\n");
    printf("  .....\n");
    printf("  Outputfile (created by user.py) should have this format: \n");
    printf("  line 1: calculated values for M basis functions of sample 1\n");
    printf("  line 2: calculated values for M basis functions of sample 2\n");
    printf("  .....\n");
    exit(1);
  }
  fclose(fp);
  struct stat sb;
  if (stat(regFile_, &sb) != 0 || !(sb.st_mode & S_IXUSR))
  {
    printf("UserRegression ERROR : User-generated executable ");
    printf("file does not have\n");
    printf("                       execute permission.\n");
    exit(1);
  }
}

// ************************************************************************
// destructor
// ------------------------------------------------------------------------
UserRegression::~UserRegression()
{
}

// ************************************************************************
// initialize
// ------------------------------------------------------------------------
int UserRegression::initialize(double *X, double *Y)
{
  int    ii, status;
  double lb, ub, hx;
 
  //**/ ==============================================================
  //**/ error checking 
  //**/ ==============================================================
  //**/ taken out because actually nSamples should be less than the 
  //**/ number of terms
  //**/if (nSamples_ <= nInputs_)
  //**/{
  //**/   printf("UserRegression::initialize INFO - not enough points.\n");
  //**/   printf("                nSamples should be >= nInputs.\n");
  //**/   return 0;
  //**/}
  status = 0;
  if (VecLBs_.length() == 0) status = 1;
  if (status == 0)
  {
    for (ii = 0; ii < nInputs_; ii++)
      if (VecLBs_[ii] >= VecUBs_[ii]) status = 1; 
  }
  if (status == 1)
  {
    printf("UserRegression::initialize ERROR - bounds have not been\n");
    printf("                initialized.\n");
    return 0;
  }
 
  //**/ ==============================================================
  //**/ scaling and processing needed only in case noAnalysis = 0
  //**/ ==============================================================
  if (noAnalysis_ != 0)
  {
    vecRegCoeffs_.setLength(1);
    vecRegCoeffs_[0] = 1.0;
  }
  else
  {
    for (ii = 0; ii < nInputs_; ii++)
    {
      lb = VecLBs_[ii];
      ub = VecUBs_[ii];
      hx = 1.0 / (ub - lb);
      if (vecXScales_[ii] == 1)
      {
        vecXNShift_[ii]  = 0.0;
        if      (lb < 0 && ub <= 0) vecXNScale_[ii] = - 1.0 / lb;
        else if (lb >= 0 && ub > 0) vecXNScale_[ii] = 1.0 / ub;
        else
        {
          hx = - lb;
          if (ub > lb) hx = ub;
          vecXNScale_[ii] = 1.0 / hx;
        }
      }
      else if (vecXScales_[ii] == 2)
      {
        if (lb < 0 && ub <= 0)
        {
          vecXNShift_[ii] = ub;
          vecXNScale_[ii] = hx;
        }
        else 
        {
          vecXNShift_[ii]  = lb;
          vecXNScale_[ii] = hx;
        }
      }
      lb = vecXNShift_[ii];
      hx = vecXNScale_[ii]; 
      printf("Input %3d : shift = %e, scale = %e\n", ii+1,lb,hx);
    }
    status = analyze(X, Y);
    if (status != 0)
    {
      printf("UserRegression::initialize - ERROR detected.\n");
      return -1;
    }
  }
  return 0;
}

// ************************************************************************
// Generate lattice data based on the input set
// ------------------------------------------------------------------------
int UserRegression::genNDGridData(double *X, double *Y, int *N2,
                                 double **X2, double **Y2)
{
  int totPts, ss;
  psVector vecYOut;

  //**/ ==============================================================
  //**/ initialization
  //**/ ==============================================================
  if (initialize(X,Y) != 0)
  {
    printf("UserRegression::genNDGridData - ERROR detected.\n");
    (*N2) = 0;
    return -1;
  }

  //**/ ==============================================================
  //**/ return if there is no request to create lattice points
  //**/ ==============================================================
  if ((*N2) == -999) return 0;

  //**/ ==============================================================
  //**/ generating regular grid data
  //**/ ==============================================================
  genNDGrid(N2, X2);
  if ((*N2) <= 0) return 0;
  totPts = (*N2);

  //**/ ==============================================================
  //**/ allocate storage for the data points and generate them
  //**/ ==============================================================
  vecYOut.setLength(totPts);
  (*Y2) = vecYOut.takeDVector();
  for (ss = 0; ss < totPts; ss++)
    (*Y2)[ss] = evaluatePoint(&((*X2)[ss*nInputs_]));
  return 0;
}

// ************************************************************************
// Generate 1D mesh results (set all other inputs to nominal values)
// ------------------------------------------------------------------------
int UserRegression::gen1DGridData(double *X, double *Y, int ind1,
                                  double *settings, int *NN, 
                                  double **XX, double **YY)
{
  int    totPts, mm, nn;
  double HX;
  psVector vecYOut, vecXT, vecXOut;

  //**/ ==============================================================
  //**/ initialize 
  //**/ ==============================================================
  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen1DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  //**/ ==============================================================
  //**/ set up for generating regular grid data
  //**/ ==============================================================
  totPts = nPtsPerDim_;
  HX = (VecUBs_[ind1] - VecLBs_[ind1]) / (nPtsPerDim_ - 1); 

  //**/ ==============================================================
  //**/ allocate storage for and then generate the data points
  //**/ this is done differently from the others because of the 
  //**/ additional costs of evaluating one at a time (->evaluate all)
  //**/ ==============================================================
  (*NN) = totPts;
  vecXOut.setLength(totPts);
  vecYOut.setLength(totPts);
  (*XX) = vecXOut.takeDVector();
  (*YY) = vecYOut.takeDVector();
  vecXT.setLength(totPts*nInputs_);
  for (mm = 0; mm < nPtsPerDim_; mm++) 
    for (nn = 0; nn < nInputs_; nn++) 
       vecXT[mm*nInputs_+nn] = settings[nn]; 
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    vecXT[mm*nInputs_+ind1] = HX * mm + VecLBs_[ind1];
    (*XX)[mm] = vecXT[mm*nInputs_+ind1];
  }
  evaluatePoint(totPts,vecXT.getDVector(),*YY);
  return 0;
}

// ************************************************************************
// Generate 2D mesh results (set all other inputs to nominal values)
// ------------------------------------------------------------------------
int UserRegression::gen2DGridData(double *X, double *Y, int ind1,
                        int ind2, double *settings, int *NN, 
                        double **XX, double **YY)
{
  int    totPts, mm, nn, kk, index;
  psVector vecYOut, vecXT, vecXOut, vecHX;

  //**/ ==============================================================
  //**/ initialize 
  //**/ ==============================================================
  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen2DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  //**/ ==============================================================
  //**/ set up for generating regular grid data
  //**/ ==============================================================
  totPts = nPtsPerDim_ * nPtsPerDim_;
  vecHX.setLength(2);
  vecHX[0] = (VecUBs_[ind1] - VecLBs_[ind1])/(nPtsPerDim_ - 1); 
  vecHX[1] = (VecUBs_[ind2] - VecLBs_[ind2])/(nPtsPerDim_ - 1); 

  //**/ ==============================================================
  //**/ allocate storage for and then generate the data points
  //**/ ==============================================================
  (*NN) = totPts;
  vecXOut.setLength(totPts*2);
  vecYOut.setLength(totPts);
  (*XX) = vecXOut.takeDVector();
  (*YY) = vecYOut.takeDVector();
  vecXT.setLength(totPts*nInputs_);
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++) 
    {
      index = mm * nPtsPerDim_ + nn;
      for (kk = 0; kk < nInputs_; kk++) 
        vecXT[index*nInputs_+kk] = settings[kk]; 
    }
  }
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      index = mm * nPtsPerDim_ + nn;
      vecXT[index*nInputs_+ind1] = vecHX[0] * mm + VecLBs_[ind1];
      vecXT[index*nInputs_+ind2] = vecHX[1] * nn + VecLBs_[ind2];
      (*XX)[index*2]   = vecXT[index*nInputs_+ind1];
      (*XX)[index*2+1] = vecXT[index*nInputs_+ind2];
    }
  }
  evaluatePoint(totPts,vecXT.getDVector(),*YY);
  return 0;
}

// ************************************************************************
// Generate 3D mesh results (setting others to some nominal values) 
// ------------------------------------------------------------------------
int UserRegression::gen3DGridData(double *X, double *Y, int ind1,
                                  int ind2, int ind3, double *settings, 
                                  int *NN, double **XX, double **YY)
{
  int totPts, mm, nn, pp, kk, index;
  psVector vecYOut, vecXT, vecXOut, vecHX;

  //**/ ==============================================================
  //**/ initialize 
  //**/ ==============================================================
  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen3DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  //**/ ==============================================================
  //**/ set up for generating regular grid data
  //**/ ==============================================================
  totPts = nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_;
  vecHX.setLength(3);
  vecHX[0] = (VecUBs_[ind1] - VecLBs_[ind1])/(nPtsPerDim_ - 1); 
  vecHX[1] = (VecUBs_[ind2] - VecLBs_[ind2])/(nPtsPerDim_ - 1); 
  vecHX[2] = (VecUBs_[ind3] - VecLBs_[ind3])/(nPtsPerDim_ - 1); 

  //**/ ==============================================================
  //**/ allocate storage for and then generate the data points
  //**/ ==============================================================
  (*NN) = totPts;
  vecXOut.setLength(totPts*3);
  vecYOut.setLength(totPts);
  (*XX) = vecXOut.takeDVector();
  (*YY) = vecYOut.takeDVector();
  vecXT.setLength(totPts*nInputs_);
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        index = mm * nPtsPerDim_ * nPtsPerDim_ + nn * nPtsPerDim_ + pp;
        for (kk = 0; kk < nInputs_; kk++)
          vecXT[index*nInputs_+kk] = settings[kk];
      }
    }
  }
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        index = mm * nPtsPerDim_ * nPtsPerDim_ + nn * nPtsPerDim_ + pp;
        vecXT[index*nInputs_+ind1] = vecHX[0] * mm + VecLBs_[ind1];
        vecXT[index*nInputs_+ind2] = vecHX[1] * nn + VecLBs_[ind2];
        vecXT[index*nInputs_+ind3] = vecHX[2] * pp + VecLBs_[ind3];
        (*XX)[index*3]   = vecXT[index*nInputs_+ind1];
        (*XX)[index*3+1] = vecXT[index*nInputs_+ind2];
        (*XX)[index*3+2] = vecXT[index*nInputs_+ind3];
      }
    }
  }
  evaluatePoint(totPts,vecXT.getDVector(),*YY);
  return 0;
}

// ************************************************************************
// Generate 4D mesh results (setting others to some nominal values) 
// ------------------------------------------------------------------------
int UserRegression::gen4DGridData(double *X, double *Y, int ind1, int ind2,
                                  int ind3, int ind4, double *settings, 
                                  int *NN, double **XX, double **YY)
{
  int totPts, mm, nn, pp, qq, kk, index;
  psVector vecYOut, vecXT, vecXOut, vecHX;

  //**/ ==============================================================
  //**/ initialize 
  //**/ ==============================================================
  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen4DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  //**/ ==============================================================
  //**/ set up for generating regular grid data
  //**/ ==============================================================
  totPts = nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_;
  vecHX.setLength(4);
  vecHX[0] = (VecUBs_[ind1] - VecLBs_[ind1])/(nPtsPerDim_ - 1); 
  vecHX[1] = (VecUBs_[ind2] - VecLBs_[ind2])/(nPtsPerDim_ - 1); 
  vecHX[2] = (VecUBs_[ind3] - VecLBs_[ind3])/(nPtsPerDim_ - 1); 
  vecHX[3] = (VecUBs_[ind4] - VecLBs_[ind4])/(nPtsPerDim_ - 1); 

  //**/ ==============================================================
  //**/ allocate storage for and then generate the data points
  //**/ ==============================================================
  (*NN) = totPts;
  vecXOut.setLength(totPts*4);
  vecYOut.setLength(totPts);
  (*XX) = vecXOut.takeDVector();
  (*YY) = vecYOut.takeDVector();
  vecXT.setLength(totPts*nInputs_);
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        for (qq = 0; qq < nPtsPerDim_; qq++)
        {
          index = mm*nPtsPerDim_*nPtsPerDim_*nPtsPerDim_ +
                  nn*nPtsPerDim_*nPtsPerDim_ + pp * nPtsPerDim_ + qq;
          for (kk = 0; kk < nInputs_; kk++)
            vecXT[index*nInputs_+kk] = settings[kk];
        }
      }
    }
  }
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        for (qq = 0; qq < nPtsPerDim_; qq++)
        {
          index = mm*nPtsPerDim_*nPtsPerDim_*nPtsPerDim_ +
                  nn*nPtsPerDim_*nPtsPerDim_ + pp * nPtsPerDim_ + qq;
          vecXT[index*nInputs_+ind1] = vecHX[0] * mm + VecLBs_[ind1];
          vecXT[index*nInputs_+ind2] = vecHX[1] * nn + VecLBs_[ind2];
          vecXT[index*nInputs_+ind3] = vecHX[2] * pp + VecLBs_[ind3];
          vecXT[index*nInputs_+ind4] = vecHX[3] * qq + VecLBs_[ind4];
          (*XX)[index*4]   = vecXT[ind1];
          (*XX)[index*4+1] = vecXT[ind2];
          (*XX)[index*4+2] = vecXT[ind3];
          (*XX)[index*4+3] = vecXT[ind4];
        }
      }
    }
  }
  evaluatePoint(totPts,vecXT.getDVector(),*YY);
  return 0;
}

// ************************************************************************
// Evaluate a given point
// ------------------------------------------------------------------------
double UserRegression::evaluatePoint(double *X)
{
  int    iOne=1;
  double Y;
  evaluatePoint(iOne, X, &Y);
  return Y;
}

// ************************************************************************
// Evaluate a number of points
// ------------------------------------------------------------------------
double UserRegression::evaluatePoint(int npts, double *X, double *Y)
{
  int    ii, ind, kk;
  double Yt, ddata;
  char   sysCmd[500], lineIn[5001];
  FILE   *fp;

  //**/ ==============================================================
  //**/ error checking
  //**/ ==============================================================
  if (vecRegCoeffs_.length() <= 0)
  {
    printf("UserRegression ERROR: need to call initialize first.\n");
    return 0.0;
  }

  //**/ ==============================================================
  //**/ write inputs to file and run
  //**/ ==============================================================
  fp = fopen("ps_input", "w");
  if (fp == NULL)
  {
    printf("fopen returned NULL in file %s line %d, exiting\n",
           __FILE__, __LINE__);
    exit(1);
  }
  fprintf(fp, "%d %d\n", npts, nInputs_);
  for (kk = 0; kk < npts; kk++)
  {
    fprintf(fp, "%d", kk+1);
    for (ii = 0; ii < nInputs_; ii++)
    {
      ddata = (X[kk*nInputs_+ii] - vecXNShift_[ii]) * vecXNScale_[ii];
      fprintf(fp, " %24.16e", ddata);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");
  fclose(fp);
  if (outputLevel_ > 2) 
    printOutTS(PL_INFO,"Evaluating basis function with user regressor...\n");
  if (psPythonOverride_ == 0)
  {
    if (psPythonInterpreter_ != NULL)
    {
      sprintf(sysCmd,"%s %s ps_input ps_output",psPythonInterpreter_,
              regFile_);
    }
    else sprintf(sysCmd,"python %s ps_input ps_output", regFile_);
  }
  else sprintf(sysCmd,"%s ps_input ps_output", regFile_);
  if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
  system(sysCmd);
  if (outputLevel_ > 2) 
    printOutTS(PL_INFO, "Basis function evaluation completed.\n");
 
  //**/ ==============================================================
  //**/ read outputs from file and compose final output
  //**/ ==============================================================
  fp = fopen("ps_output", "r");
  if (fp == NULL)
  {
    printf("fopen returned NULL in file %s line %d, exiting\n",
           __FILE__, __LINE__);
     exit(1);
  }
  for (kk = 0; kk < npts; kk++)
  {
    if (kk == 0)
    {
      fscanf(fp, "%s", lineIn); 
      if (lineIn[0] == '#')
      {
        fgets(lineIn, 5000, fp);
        fscanf(fp, "%d", &ind);
      }
      else sscanf(lineIn, "%d", &ind);
    }
    else fscanf(fp, "%d", &ind);
    if (ind != kk+1)
    {
      printf("ERROR: user output file does not have correct format.\n");
      printf("  Expected index = %d, actual index = %d\n",kk+1,ind);
      fclose(fp);
      exit(1);
    }
    Yt = 0.0;
    for (ii = 0; ii < numTerms_; ii++)
    {
      fscanf(fp, "%lg", &ddata);
      Yt += vecRegCoeffs_[ii] * ddata;
    }
    if (fgets(lineIn, 5000, fp) == NULL && kk < npts-1)
    {
      printf("ERROR: user output file does not have enough data (%d).\n",
             kk);
      fclose(fp);
      exit(1);
    }
    Y[kk] = Yt;
  }
  fclose(fp);
  unlink("ps_input");
  unlink("ps_output");
  return 0.0;
}

// ************************************************************************
// Evaluate a given point and also its standard deviation
// ------------------------------------------------------------------------
double UserRegression::evaluatePointFuzzy(double *X, double &std)
{
   int    iOne=1;
   double Y, ddata;
   evaluatePointFuzzy(iOne, X, &Y, &ddata);
   std = ddata;
   return Y;
}

// ************************************************************************
// Evaluate a number of points and also their standard deviations
// ------------------------------------------------------------------------
double UserRegression::evaluatePointFuzzy(int npts, double *X, double *Y,
                                          double *Ystd)
{
  int    ii, jj, kk;
  double std, ddata, mean, dtmp;
  char   sysCmd[500], lineIn[5001];
  FILE   *fp;

  //**/ ==============================================================
  //**/ error checking
  //**/ ==============================================================
  if (vecRegCoeffs_.length() <= 0)
  {
    printf("UserRegression ERROR: need to call initialize first.\n");
    return 0.0;
  }

  //**/ ==============================================================
  //**/ if no analysis has been performed, no fuzziness
  //**/ ==============================================================
  if (noAnalysis_ == 1)
  {
    evaluatePoint(npts, X, Y);
    for (kk = 0; kk < npts; kk++) Ystd[kk] = 0.0;
  }
  else
  {
    //**/ ============================================================
    //**/ write out npts points to a file called ps_input
    //**/ ============================================================
    fp = fopen("ps_input", "w");
    if (fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
    }
    fprintf(fp, "%d %d\n", npts, nInputs_);
    for (kk = 0; kk < npts; kk++)
    {
      fprintf(fp, "%d", kk+1);
      for (ii = 0; ii < nInputs_; ii++)
      {
        ddata = (X[kk*nInputs_+ii] - vecXNShift_[ii]) * vecXNScale_[ii];
        fprintf(fp, " %24.16e", ddata);
      }
      fprintf(fp, "\n");
    }
    fprintf(fp, "\n");
    fclose(fp);

    //**/ ============================================================
    //**/ call user function
    //**/ ============================================================
    if (psPythonOverride_ == 0)
    {
      if (psPythonInterpreter_ != NULL)
      {
        sprintf(sysCmd,"%s %s ps_input ps_output",psPythonInterpreter_,
                regFile_);
      }
      else sprintf(sysCmd,"python %s ps_input ps_output",regFile_);
    }
    else sprintf(sysCmd,"%s ps_input ps_output", regFile_);
    if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
    system(sysCmd);
 
    //**/ ============================================================
    //**/ read ps_output for outputs
    //**/ ============================================================
    fp = fopen("ps_output", "r");
    if (fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
    }
    psVector vecXS;
    vecXS.setLength(numTerms_);
    for (kk = 0; kk < npts; kk++)
    {
      //**/ read output values 
      if (kk == 0)
      {
        fscanf(fp, "%s", lineIn); 
        if (lineIn[0] == '#')
        {
          fgets(lineIn, 5000, fp);
          fscanf(fp, "%d", &ii);
        }
        else sscanf(lineIn, "%d", &ii);
      }
      else fscanf(fp, "%d", &ii);
      if (ii != kk+1)
      {
        printf("ERROR: user output file does not have correct format.\n");
        printf("  Expected index = %d, actual index = %d\n",kk+1,ii);
        fclose(fp);
        exit(1);
      }
      for (ii = 0; ii < numTerms_; ii++) 
      {
        fscanf(fp, "%lg", &ddata);
        vecXS[ii] = ddata;
      }
      if (fgets(lineIn, 5000, fp) == NULL && kk < npts-1)
      {
        printf("ERROR: user output file does not have enough data (%d).\n",
               kk);
        fclose(fp);
        exit(1);
      }
      //**/ calculate outputs/standard deviations using regression formula
      mean = 0.0;
      for (ii = 0; ii < numTerms_; ii++) 
        mean += vecRegCoeffs_[ii] * vecXS[ii];
      Y[kk] = mean;
      std = 0.0;
      for (ii = 0; ii < numTerms_; ii++)
      {
        dtmp = 0.0;
        for (jj = 0; jj < numTerms_; jj++)
          dtmp += invCovMat_.getEntry(ii,jj) * vecXS[jj];
        std += dtmp * vecXS[ii];
      }
      Ystd[kk] = sqrt(std);
    }
    fclose(fp);
    //**/ clean up
    unlink("ps_input");
    unlink("ps_output");
  }
  return 0.0;
}

// ************************************************************************
// perform regression analysis
// ------------------------------------------------------------------------
int UserRegression::analyze(double *Xin, double *Y)
{
  psVector VecX, VecY;
  VecX.load(nSamples_*nInputs_, Xin);
  VecY.load(nSamples_, Y);
  return analyze(VecX, VecY);
}

// ************************************************************************
// perform regression analysis
// ------------------------------------------------------------------------
int UserRegression::analyze(psVector VecX, psVector VecY)
{
  int    N, M, mm, nn, wlen, info, NRevised;
  double SSresid, SStotal, R2, var, esum, ymax, *arrayXX, *UU, *VV;
  char   pString[100];
  FILE   *fp;
  psMatrix eigMatT, MatXX, MatA;
  psVector eigVals;

  //**/ ==============================================================
  //**/ error checking
  //**/ ==============================================================
  if (nSamples_ <= numTerms_)
  {
    printf("UserRegression::analyze ERROR - sample size too small.\n");
    return -1;
  } 
   
  //**/ ==============================================================
  //**/ obtain regression matrix dimension
  //**/ ==============================================================
  N = loadXMatrix(VecX, MatXX);
  M = nSamples_;

  //**/ ==============================================================
  //**/ set up matrix A for SVD
  //**/ ==============================================================
  psVector VecA;
  VecA.setLength(M*N);
  arrayXX = MatXX.getMatrix1D();
  for (mm = 0; mm < M; mm++)
    for (nn = 0; nn < N; nn++)
      VecA[mm+nn*M] = sqrt(VecWghts_[mm]) * arrayXX[mm+nn*M];
  MatA.load(M, N, VecA.getDVector());

  //**/ ==============================================================
  //**/ diagnostics
  //**/ ==============================================================
  if (psConfig_.MasterModeIsOn())
  {
    fp = fopen("user_regression_matrix.m", "w");
    if(fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
    }
    fprintf(fp, "%% the sample matrix where svd is computed\n");
    fprintf(fp, "%% the last column is the right hand side\n");
    fprintf(fp, "%% B is the vector of coefficients\n");
    fprintf(fp, "AA = [\n");
    for (mm = 0; mm < M; mm++)
    {
      for (nn = 0; nn < N; nn++)
        fprintf(fp, "%24.16e ", VecA[mm+nn*M]);
      fprintf(fp, "%24.16e \n",VecY[mm]);
    }
    fprintf(fp, "];\n");
    fprintf(fp, "A = AA(:,1:%d);\n", N);
    fprintf(fp, "Y = AA(:,%d);\n", N+1);
    fprintf(fp, "B = A \\ Y;\n");
    fclose(fp);
    printf("Regression matrix written to user_regression_matrix.m\n");
  }

  //**/ ==============================================================
  //**/ perform SVD
  //**/ ==============================================================
  psMatrix MatU, MatV;
  psVector VecS;
  if (outputLevel_ > 3) printf("Running SVD ...\n");
  info = MatA.computeSVD(MatU, VecS, MatV);
  if (outputLevel_ > 3) 
    printf("SVD completed: status = %d (should be 0).\n",info);

  if (info != 0)
  {
    printf("* UserRegression Info: dgesvd returns a nonzero (%d).\n",info);
    printf("* UserRegression terminates further processing.\n");
    return -1;
  }

  //**/ ==============================================================
  //**/ eliminate the noise components 
  //**/ ==============================================================
  mm = 0;
  for (nn = 0; nn < N; nn++) if (VecS[nn] < 0) mm++;
  if (mm > 0)
  {
    printf("* UserRegression WARNING: some of the singular values\n");
    printf("*            are < 0. May spell trouble but will\n");
    printf("*            proceed anyway (%d).\n",mm);
  }
  if (VecS[0] == 0.0) NRevised = 0;
  else
  {
    NRevised = N;
    for (nn = 1; nn < N; nn++)
      if (VecS[nn-1] > 0 && VecS[nn]/VecS[nn-1] < 1.0e-8) NRevised--;
  }
  if (NRevised < N)
  {
    printf("* UserRegression ERROR: true rank of sample = %d (need %d)\n",
           NRevised, N);
    return -1;
  }
  if (psConfig_.MasterModeIsOn())
  {
    printf("UserRegression: matrix singular values \n");
    printf("The VERY small ones may cause poor numerical accuracy,\n");
    printf("but not keeping them may ruin the approximation power.\n");
    printf("So, select them judiciously.\n");
    for (nn = 0; nn < N; nn++)
      printf("Singular value %5d = %e\n", nn+1, VecS[nn]);
    sprintf(pString, "How many to keep (1 - %d, 0 - all) ? ", N);
    NRevised = getInt(0,N,pString);
    if (NRevised == 0) NRevised = N;
    for (nn = NRevised; nn < N; nn++) VecS[nn] = 0.0;
  }
  else
  {
    NRevised = N;
    for (nn = 1; nn < N; nn++)
    {
      if (VecS[nn-1] > 0.0 && VecS[nn]/VecS[nn-1] < 1.0e-8)
      {
        VecS[nn] = 0.0;
        NRevised--;
      }
    }
  }

  //**/ ==============================================================
  //**/ compute B
  //**/ ==============================================================
  psVector VecW, VecB;
  VecW.setLength(M+N);
  UU = MatU.getMatrix1D();
  for (mm = 0; mm < NRevised; mm++)
  {
    VecW[mm] = 0.0;
    for (nn = 0; nn < M; nn++)
      VecW[mm] += UU[nn+mm*M] * sqrt(VecWghts_[nn]) * VecY[nn];
  }
  for (nn = 0; nn < NRevised; nn++) VecW[nn] /= VecS[nn];
  for (nn = NRevised; nn < N; nn++) VecW[nn] = 0.0;
  VecB.setLength(N);
  VV = MatV.getMatrix1D();
  for (mm = 0; mm < N; mm++)
  {
    VecB[mm] = 0.0;
    for (nn = 0; nn < NRevised; nn++) VecB[mm] += VV[nn+mm*N] * VecW[nn];
  }

  //**/ ==============================================================
  //**/ store eigenvectors VecV and eigenvalues VecS^2
  //**/ ==============================================================
  eigMatT.load(N, N, VV);
  eigVals.load(N, VecS.getDVector());
  for (nn = 0; nn < N; nn++) eigVals[nn] = pow(eigVals[nn], 2.0);

  //**/ ==============================================================
  //**/ compute residual
  //**/ ==============================================================
  if (psConfig_.MasterModeIsOn())
  {
    fp = fopen("user_regression_error.m", "w");
    if(fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
            __FILE__, __LINE__);
      exit(1);
    }
    fprintf(fp, "%% This file contains errors of each data point.\n");
  }
  else fp = NULL;

  esum = ymax = 0.0;
  for (mm = 0; mm < nSamples_; mm++)
  {
    VecW[mm] = 0.0;
    for (nn = 0; nn < N; nn++)
      VecW[mm] = VecW[mm] + arrayXX[mm+nn*nSamples_] * VecB[nn];
    VecW[mm] = VecW[mm] - VecY[mm];
    esum = esum + VecW[mm] * VecW[mm] * VecWghts_[mm];
    if (fp != NULL) 
      fprintf(fp, "%6d %24.16e\n",mm+1,VecW[mm]*sqrt(VecWghts_[mm]));
    if (PABS(VecY[mm]) > ymax) ymax = PABS(VecY[mm]);
  }
  esum /= (double) nSamples_;
  esum = sqrt(esum);
  printAsterisks(PL_INFO, 0);
  printf("*            User Regression Analysis Statistics\n");
  printEquals(PL_INFO, 0);
  printf("* UserRegression:: LS mean error = %11.4e (max=%11.4e)\n",
         esum, ymax); 

  if (fp != NULL)
  {
    fclose(fp);
    printf("FILE user_regression_error.m contains data errors.\n");
  }

  //**/ ==============================================================
  //**/ form compute SS statistics 
  //**/ ==============================================================
  computeSS(MatXX, VecY, VecB, SSresid, SStotal);
  if (SStotal == 0.0) R2 = 1.0;
  else                R2  = 1.0 - SSresid / SStotal;
  if (nSamples_ > N) var = SSresid / (double) (nSamples_ - N);
  else               var = 0.0;
  if (var < 0)
  { 
    if (PABS(var) > 1.0e-12)
    {
      printf("UserRegression WARNING: variance < 0.\n");
      printf("    Temporarily absolutize var (may have problems).\n");
      var = PABS(var); 
    }
    else var = 0;
  }
  vecRegCoeffs_.load(VecB);

  //**/ ==============================================================
  //**/ find variance of each coefficient 
  //**/ ==============================================================
  psVector VecBstd;
  VecBstd.setLength(N);
  computeCoeffVariance(eigMatT, eigVals, var);
  for (mm = 0; mm < N; mm++)
    VecBstd[mm] = sqrt(invCovMat_.getEntry(mm,mm));

  //**/ ==============================================================
  //**/ print out regression coefficients 
  //**/ ==============================================================
  if (outputLevel_ >= 0)
  {
    if (outputLevel_ > 0) printRC(VecB, VecBstd, MatXX, VecY);
    printf("* UserRegression model R-square = %12.4e\n", R2);
    printf("* adjusted   R-square = %12.4e\n",
           1.0 - (1.0 - R2) * ((M - 1) / (M - N - 1)));
     printEquals(PL_INFO, 0);
  }

  //**/ ==============================================================
  //**/ generate standalone response surface function
  //**/ ==============================================================
  fp = NULL;
  if (psConfig_.RSCodeGenIsOn()) fp = fopen("psuade_rs.info", "w");
  if (fp != NULL)
  {
    fprintf(fp,"/* *******************************************/\n");
    fprintf(fp,"/* User regression interpolator form PSUADE. */\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"/* This file contains information for interpolation\n");
    fprintf(fp,"   using response surface. Follow the steps below:\n");
    fprintf(fp,"   1. move this file to *.c file (e.g. main.c)\n");
    fprintf(fp,"   2. Modify the main.c program\n");
    fprintf(fp,"      a. replace func with your user-defined function\n");
    fprintf(fp,"   3. Compile main.c (cc -o main main.c -lm) \n");
    fprintf(fp,"   4. run: main input output\n");
    fprintf(fp,"          where input has the number of inputs and\n");
    fprintf(fp,"          the input values\n");
    fprintf(fp,"*/\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"#include <math.h>\n");
    fprintf(fp,"#include <stdlib.h>\n");
    fprintf(fp,"#include <stdio.h>\n");
    fprintf(fp,"int interpolate(int,double*,double*,double*);\n");
    fprintf(fp,"main(int argc, char **argv) {\n");
    fprintf(fp,"  int    i, iOne=1, nInps;\n");
    fprintf(fp,"  double X[%d], Y, S;\n",nInputs_);
    fprintf(fp,"  FILE   *fIn=NULL, *fOut=NULL;\n");
    fprintf(fp,"  if (argc < 3) {\n");
    fprintf(fp,"     printf(\"ERROR: not enough argument.\\n\");\n");
    fprintf(fp,"     exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  fIn = fopen(argv[1], \"r\");\n");
    fprintf(fp,"  if (fIn == NULL) {\n");
    fprintf(fp,"     printf(\"ERROR: cannot open input file.\\n\");\n");
    fprintf(fp,"     exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  fscanf(fIn, \"%%d\", &nInps);\n");
    fprintf(fp,"  if (nInps != %d) {\n", nInputs_);
    fprintf(fp,"    printf(\"ERROR - wrong nInputs.\\n\");\n");
    fprintf(fp,"    exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  for (i=0; i<%d; i++) fscanf(fIn, \"%%lg\", &X[i]);\n",
            nInputs_);
    fprintf(fp,"  fclose(fIn);\n");
    fprintf(fp,"  interpolate(iOne, X, &Y, &S);\n");
    fprintf(fp,"  printf(\"Y = %%e\\n\", Y);\n");
    fprintf(fp,"  printf(\"S = %%e\\n\", S);\n");
    fprintf(fp,"  fOut = fopen(argv[2], \"w\");\n");
    fprintf(fp,"  if (fOut == NULL) {\n");
    fprintf(fp,"     printf(\"ERROR: cannot open output file.\\n\");\n");
    fprintf(fp,"     exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  fprintf(fOut,\" %%e\\n\", Y);\n");
    fprintf(fp,"  fclose(fOut);\n");
    fprintf(fp,"}\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"/* Regression interpolation function         */\n");
    fprintf(fp,"/* X[0], X[1],   .. X[m-1]   - first point\n");
    fprintf(fp," * X[m], X[m+1], .. X[2*m-1] - second point\n");
    fprintf(fp," * ... */\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"static double\n");
    fprintf(fp,"regCoefs[%d] = \n", N);
    fprintf(fp,"{\n");
    for (mm = 0; mm < N; mm++)
      fprintf(fp," %24.16e,\n", vecRegCoeffs_[mm]);
    fprintf(fp,"};\n");
    fprintf(fp,"static double\n");
    fprintf(fp,"XStat[%d][2] = \n", nInputs_);
    fprintf(fp,"{\n");
    for (mm = 0; mm < nInputs_; mm++)
      fprintf(fp,"  { %24.16e , %24.16e},\n",vecXNShift_[mm],
              vecXNScale_[mm]);
    fprintf(fp,"};\n");
    fprintf(fp,"static double invCovMat[%d][%d] = \n", N, N);
    fprintf(fp,"{\n");
    for (mm = 0; mm < N; mm++)
    {
      fprintf(fp," { %24.16e", invCovMat_.getEntry(mm,0));
      for (nn = 1; nn < N; nn++)
        fprintf(fp,", %24.16e", invCovMat_.getEntry(mm,nn));
      fprintf(fp," },\n");
    }
    fprintf(fp,"};\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"int func(int nInps, double *X, double *Y);\n");
    fprintf(fp,"int interpolate(int npts,double *X,double *Y,double *S){\n");
    fprintf(fp,"  int    kk, ii, jj, nInps=%d;\n",nInputs_);
    fprintf(fp,"  int    nterms=%d;\n",numTerms_);
    fprintf(fp,"  double y, *x, *u, *yy, std, dtmp;\n");
    fprintf(fp,"  u = (double *) malloc(%d *sizeof(double));\n",numTerms_);
    fprintf(fp,"  x = (double *) malloc(nInps*sizeof(double));\n");
    fprintf(fp,"  for (ii = 0; ii < npts; ii++) {\n");
    fprintf(fp,"    for (jj = 0; jj < nInps; jj++)\n");
    fprintf(fp,"      x[jj] = (X[ii*nInps+jj]-XStat[jj][0])/XStat[jj][1];\n");
    fprintf(fp,"    func(nInps,x,u);\n");
    fprintf(fp,"    y = 0.0;\n");
    fprintf(fp,"    for (jj = 0; jj < nterms; jj++)\n");
    fprintf(fp,"      y += regCoefs[jj] * u[jj];\n");
    fprintf(fp,"    Y[ii] = y * %e + %e;\n", YStd_, YMean_);
    fprintf(fp,"    std = 0.0;\n");
    fprintf(fp,"    for (jj = 0; jj < nterms; jj++) {\n");
    fprintf(fp,"      dtmp = 0.0;\n");
    fprintf(fp,"      for (kk = 0; kk < nterms; kk++)\n");
    fprintf(fp,"        dtmp += invCovMat[jj][kk] * u[kk];\n");
    fprintf(fp,"      std += dtmp * u[jj];\n");
    fprintf(fp,"    }\n");
    fprintf(fp,"    std = sqrt(std);\n");
    fprintf(fp,"    S[ii] = std;\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  free(u);\n");
    fprintf(fp,"  free(x);\n");
    fprintf(fp,"  return 0;\n");
    fprintf(fp,"}\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"/* Put your function definition here.        */\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"int func(int nInps, double *X, double *Y){\n");
    fprintf(fp,"  Y[0] = X[0] * X[0];\n");
    fprintf(fp,"  Y[1] = X[1] * X[1];\n");
    fprintf(fp,"  return 0;\n");
    fprintf(fp,"}\n");
    fprintf(fp,"/* ==============================================*/\n");
    fclose(fp);
    printf("FILE psuade_rs.info contains the user regression interpolator\n");
  }
  fp = NULL;
  if (psConfig_.RSCodeGenIsOn()) fp = fopen("psuade_rs.py", "w");
  if (fp != NULL)
  {
    fprintf(fp,"#!/usr/bin/python\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# Response surface interpolator from PSUADE\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"# This file contains information for interpolation\n");
    fprintf(fp,"# using response surface. Follow the steps below:\n");
    fprintf(fp,"#  1. move this file to *.py file (e.g. interpolate.py)\n");
    fprintf(fp,"#  2. modify 'func' to reflect your basis functions.\n");
    fprintf(fp,"#  3. make sure the first line points to your Python\n");
    fprintf(fp,"#  4. prepare your new sample points to be interpolated\n");
    fprintf(fp,"#     in a text file (e.g. infile) with the format below:\n");
    fprintf(fp,"#    <number of sample points M> <number of inputs n>\n");
    fprintf(fp,"#    1 input1 input2 ...inputn\n");
    fprintf(fp,"#    2 input1 input2 ...inputn\n");
    fprintf(fp,"#    ....\n");
    fprintf(fp,"#    M input1 input2 ...inputn\n");
    fprintf(fp,"#  5. run: interpolate.py infile outfile\n");
    fprintf(fp,"#     where <outfile> will have the interpolated values.\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"import sys\n");
    fprintf(fp,"import string\n");
    fprintf(fp,"import math\n\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"# User regressioin interpolation\n");
    fprintf(fp,"#==================================================\n");
    fwriteRSPythonCommon(fp);
    fprintf(fp,"regCoefs = [\n");
    for (mm = 0; mm < N-1; mm++)
      fprintf(fp," %24.16e,\n", vecRegCoeffs_[mm]);
    fprintf(fp," %24.16e ]\n", vecRegCoeffs_[N-1]);
    fprintf(fp,"XStat = [\n");
    for (mm = 0; mm < nInputs_; mm++)
      fprintf(fp,"  [ %24.16e , %24.16e ],\n",vecXNShift_[mm],
              vecXNScale_[mm]);
    fprintf(fp,"]\n");
    fprintf(fp,"invCovMat = [\n");
    for (mm = 0; mm < N; mm++)
    {
      fprintf(fp," [ %24.16e", invCovMat_.getEntry(mm,0));
      for (nn = 1; nn < N; nn++)
        fprintf(fp,", %24.16e", invCovMat_.getEntry(mm,nn));
      fprintf(fp," ]\n");
    }
    fprintf(fp,"]\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# define your function here \n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"def func(X) : \n");
    fprintf(fp,"  nn = len(X)\n");
    fprintf(fp,"  mm = %d\n", numTerms_);
    fprintf(fp,"  U  = mm * [0.0]\n");
    fprintf(fp,"  for ii in range(mm): \n");
    fprintf(fp,"#    fill in your ii-th basis function\n");
    fprintf(fp,"#    U[ii] = evalBasisFcn(ii,X)\n");
    fprintf(fp,"  return U\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# Regression interpolation function  \n");
    fprintf(fp,"# X[0], X[1],   .. X[m-1]   - first point\n");
    fprintf(fp,"# X[m], X[m+1], .. X[2*m-1] - second point\n");
    fprintf(fp,"# ... \n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"def interpolate(X): \n");
    fprintf(fp,"  nSamp = int(len(X) / %d)\n", nInputs_);
    fprintf(fp,"  Xt = %d * [0.0]\n", nInputs_);
    fprintf(fp,"  Ys = 2 * nSamp * [0.0]\n");
    fprintf(fp,"  for ss in range(nSamp) : \n");
    fprintf(fp,"    for ii in range(%d) : \n", nInputs_);
    fprintf(fp,"      Xt[ii] = (X[ss*%d+ii]-XStat[ii][0])/XStat[ii][1]\n",
            nInputs_);
    fprintf(fp,"    U = func(Xt)\n");
    fprintf(fp,"    Y = 0.0\n");
    fprintf(fp,"    for jj in range(%d) : \n", numTerms_);
    fprintf(fp,"      Y += regCoefs[jj] * U[jj]\n");
    fprintf(fp,"    Ys[2*ss] = Y * %e + %e;\n", YStd_, YMean_);
    fprintf(fp,"    std = 0.0;\n");
    fprintf(fp,"    for jj in range(%d): \n", numTerms_);
    fprintf(fp,"      dtmp = 0.0\n");
    fprintf(fp,"      for kk in range(%d): \n", numTerms_);
    fprintf(fp,"        dtmp = dtmp + invCovMat[jj][kk] * U[kk]\n");
    fprintf(fp,"      std = std + dtmp * U[jj]\n");
    fprintf(fp,"    Ys[2*ss+1] = math.sqrt(std)\n");
    fprintf(fp,"  return Ys\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# main program\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"infileName  = sys.argv[1]\n");
    fprintf(fp,"outfileName = sys.argv[2]\n");
    fprintf(fp,"inputs = getInputData(infileName)\n");
    fprintf(fp,"outputs = interpolate(inputs)\n");
    fprintf(fp,"genOutputFile(outfileName, outputs)\n");
    fprintf(fp,"###################################################\n");
    fclose(fp);
    printf("FILE psuade_rs.py contains the user regression interpolator.\n");
  }
  return 0;
}

// *************************************************************************
// load the X matrix
// -------------------------------------------------------------------------
int UserRegression::loadXMatrix(psVector VecX, psMatrix &MatXX)
{
  int    M, N, mm, kk;
  double *arrayXX;
  char   sysCmd[500], lineIn[5001];
  FILE   *fp;

  M = nSamples_;
  N = numTerms_;
  MatXX.setDim(M, N);
  arrayXX = MatXX.getMatrix1D();
  if (psPythonOverride_ == 0)
  {
    if (psPythonInterpreter_ != NULL)
    {
      sprintf(sysCmd,"%s %s ps_input ps_output",
              psPythonInterpreter_,regFile_);
    }
    else
    {
      sprintf(sysCmd,"python %s ps_input ps_output",regFile_);
    }
  }
  else
  {
    sprintf(sysCmd,"%s ps_input ps_output",regFile_);
  }
  fp = fopen("ps_input", "w");
  if(fp == NULL)
  {
    printf("file 'ps_input' expected but not found.\n");
    printf("fopen returned NULL in file %s line %d, exiting\n",
           __FILE__, __LINE__);
    exit(1);
  }
  fprintf(fp, "%d %d\n", M, nInputs_);
  for (mm = 0; mm < M; mm++)
  {
    fprintf(fp, "%d", mm+1);
    for (kk = 0; kk < nInputs_; kk++)
      fprintf(fp, " %e", 
           (VecX[mm*nInputs_+kk]-vecXNShift_[kk])*vecXNScale_[kk]);
    fprintf(fp, "\n");
  }
  fclose(fp);
  if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
  system(sysCmd);
  fp = fopen("ps_output", "r");
  if (fp == NULL)
  {
    printf("file 'ps_output' expected but not found.\n");
    printf("fopen returned NULL in file %s line %d, exiting\n", 
            __FILE__, __LINE__);
    exit(1);
  }
  for (mm = 0; mm < M; mm++)
  {
    if (mm == 0)
    {
      fscanf(fp, "%s", lineIn); 
      if (lineIn[0] == '#')
      {
        fgets(lineIn, 5000, fp);
        fscanf(fp, "%d", &kk);
      }
      else sscanf(lineIn, "%d", &kk);
    }
    else fscanf(fp, "%d", &kk);
    if (kk != mm+1)
    {
      printf("ERROR: user output file does not have correct format.\n");
      printf("  Expected index = %d, actual index = %d\n",mm+1,kk);
      fclose(fp);
      exit(1);
    }
    for (kk = 0; kk < N; kk++) fscanf(fp, "%lg", &arrayXX[M*kk+mm]);
    if ((fgets(lineIn, 5000, fp) == NULL) && (mm < M-1))
    {
      printf("ERROR: user output file does not have enough data (%d).\n",
             mm);
      printf("    => %s\n",lineIn);
      fclose(fp);
      exit(1);
    }
  }
  fclose(fp);
  unlink("ps_input");
  unlink("ps_output");
  return N;
}

// *************************************************************************
// compute SS (sum of squares) statistics
//**/ SSred = (Y - Xb)' W (Y - Xb)
//**/       = Y' W Y - 2 b 'X W 'Y + b' X' W X b
//**/       = Y' W Y - 2 b' X' W Y + b' X' W Y  (since X'WXb=X'WY)
//**/       = Y' W Y - b' X' W Y = (Y - Xb)' W Y
//**/ SStot = Y' W Y - N * (mean (W^(1/2) Y))^2
// -------------------------------------------------------------------------
int UserRegression::computeSS(psMatrix MatXX, psVector VecY, psVector VecB,
                              double &SSresid, double &SStotal)
{
  int    nn, mm, N;
  double rdata, ymean, SSreg, ddata, SSresidCheck, *arrayXX;
                                                                                
  N = VecB.length();
  arrayXX = MatXX.getMatrix1D();
  SSresid = SSresidCheck = SStotal = SSreg = ymean = 0.0;
  for (mm = 0; mm < nSamples_; mm++)
    ymean += (sqrt(VecWghts_[mm]) * VecY[mm]);
  ymean /= (double) nSamples_;
  for (mm = 0; mm < nSamples_; mm++)
  {
    ddata = 0.0;
    for (nn = 0; nn < N; nn++) ddata += (arrayXX[mm+nn*nSamples_]*VecB[nn]);
    rdata = VecY[mm] - ddata;
    SSresid += VecY[mm] * rdata * VecWghts_[mm];
    SSresidCheck += rdata * rdata * VecWghts_[mm];
    SSreg += (ddata - ymean) * (ddata - ymean);
  }
  for (mm = 0; mm < nSamples_; mm++)
    SStotal += VecWghts_[mm] * (VecY[mm] - ymean) * (VecY[mm] - ymean);
  if (outputLevel_ > 0)
  {
    printf("* UserRegression: SStot  = %24.16e\n", SStotal);
    printf("* UserRegression: SSreg  = %24.16e\n", SSreg);
    printf("* UserRegression: SSres  = %24.16e\n", SSresid);
    printf("* UserRegression: SSres  = %24.16e (true)\n", SSresidCheck);
  }
  SSresid = SSresidCheck;
  if (outputLevel_ > 0 && nSamples_ != N)
  {
    printf("* UserRegression: eps(Y) = %24.16e\n",
           SSresidCheck/(nSamples_-N));
  }
  return 0;
}

// *************************************************************************
// compute coefficient variance ((diagonal of sigma^2 (X' X)^(-1))
// -------------------------------------------------------------------------
int UserRegression::computeCoeffVariance(psMatrix &eigMatT, 
                                         psVector &eigVals, double var)
{
  int      ii, jj, nRows;
  double   invEig, dtmp;
  psMatrix tMat;

  nRows = eigMatT.nrows();
  tMat.setDim(nRows, nRows);

  //**/ compute sigma^2 V * S^{-2}
  for (ii = 0; ii < nRows; ii++)
  {
    invEig = eigVals[ii];
    if (invEig != 0.0) invEig = 1.0 / invEig;
    for (jj = 0; jj < nRows; jj++)
    {
      dtmp = invEig * eigMatT.getEntry(ii,jj) * var;
      tMat.setEntry(jj, ii, dtmp);
    }
  }
  //**/ compute (sigma^2 V * S^{-2}) * V^T
  tMat.matmult(eigMatT, invCovMat_);
  if (psConfig_.MasterModeIsOn())
  {
    printf("invCovMat = \n");
    invCovMat_.print();
  }
  return 0;
}

// ************************************************************************
// print statistics
// ------------------------------------------------------------------------
int UserRegression::printRC(psVector VecB,psVector VecBstd,psMatrix,
                            psVector VecY)
{
  int    ii;
  double coef;

  printDashes(PL_INFO, 0);
  printf("*  Term    coefficient     std. error     t-value\n");
  for (ii = 0; ii < numTerms_; ii++)
  {
    if (PABS(VecBstd[ii]) < 1.0e-15) coef = 0.0;
    else                             coef = VecB[ii] / VecBstd[ii]; 
    printf("*   %3d   %12.4e   %12.4e   %12.4e\n",ii+1,VecB[ii],
           VecBstd[ii],coef);
  }
  printDashes(PL_INFO, 0);
  return 0;
}

// ************************************************************************
// set parameters
// ------------------------------------------------------------------------
double UserRegression::setParams(int targc, char **targv)
{
  struct stat sb;
  FILE   *fp;
  if (targc > 0 && !strcmp(targv[0], "set_user_script"))
  {
    if (targc < 2)
    {
      printf("UserRegression ERROR: setParam - in setting user_script\n");
      exit(1);
    }
    strncpy(regFile_, targv[1], 1000);
    fp = fopen(regFile_, "r");
    if (fp == NULL)
    {
      printf("UserRegression ERROR: user executable %s not found.\n",
             regFile_);
      exit(1);
    }
    fclose(fp);
    if (stat(regFile_, &sb) != 0 || !(sb.st_mode & S_IXUSR))
    {
      printf("UserRegression WARNING : User-provided executable does\n");
      printf("                         not have execute permission.\n");
      exit(1);
    }
  }
  return 0.0;
}

